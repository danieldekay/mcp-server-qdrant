# Data Model: PDF Filter Parameters

**Feature**: Fix PDF Filter Parameter Exposure in MCP Tool Interface
**Date**: 2026-01-21

## Overview

This document describes the data structures involved in exposing PDF metadata filter parameters through the MCP tool interface. Based on the research findings, the architecture is correct but may require verification or workaround implementation depending on FastMCP behavior.

## Core Entities

### FilterableField (Existing)

**Purpose**: Configuration object defining a metadata field that can be filtered

**Location**: `src/mcp_server_qdrant/settings.py`

**Attributes**:

- `name: str` - Field name in metadata (e.g., "document_id")
- `description: str` - Human-readable description for MCP tool parameter
- `field_type: Literal["keyword", "integer", "float", "boolean"]` - Data type
- `condition: Literal["==", "!=", ">", ">=", "<", "<=", "any", "except"] | None` - Filter operation
- `required: bool` - Whether parameter is required (default: False)

**PDF Metadata Instances**:

```python
FilterableField(
    name="document_id",
    description="The unique identifier of the document",
    field_type="keyword",
    condition="==",
    required=False
)

FilterableField(
    name="physical_page_index",
    description="The 0-based physical index of the page",
    field_type="integer",
    condition="==",
    required=False
)

FilterableField(
    name="page_label",
    description="The original page numbering label (e.g., 'iv', '45')",
    field_type="keyword",
    condition="==",
    required=False
)
```

**State Transitions**: Immutable after initialization (Pydantic BaseModel)

**Validation Rules**:

- `name` must be non-empty string
- `field_type` must match condition (e.g., float only supports range operators)
- If `required=True`, `condition` must not be None

### MCP Tool Parameter (Generated)

**Purpose**: Dynamically generated function parameter for MCP tool signature

**Generated By**: `wrap_filters()` function

**Structure**:

```python
# For document_id
inspect.Parameter(
    name="document_id",
    kind=inspect.Parameter.POSITIONAL_OR_KEYWORD,
    default=None,  # All filter parameters are optional
    annotation=Annotated[Optional[str], Field(
        description="The unique identifier of the document"
    )]
)

# For physical_page_index
inspect.Parameter(
    name="physical_page_index",
    kind=inspect.Parameter.POSITIONAL_OR_KEYWORD,
    default=None,
    annotation=Annotated[Optional[int], Field(
        description="The 0-based physical index of the page"
    )]
)

# For page_label
inspect.Parameter(
    name="page_label",
    kind=inspect.Parameter.POSITIONAL_OR_KEYWORD,
    default=None,
    annotation=Annotated[Optional[str], Field(
        description="The original page numbering label (e.g., 'iv', '45')"
    )]
)
```

**Lifecycle**:

1. Created during server initialization in `QdrantMCPServer.setup_tools()`
2. Inserted into function signature after original parameters
3. Stored in `__signature__` and `__annotations__` attributes
4. Read by FastMCP during tool registration

### Qdrant Filter Condition (Runtime)

**Purpose**: Qdrant query filter constructed from provided parameter values

**Generated By**: `make_filter()` function

**Structure**:

```python
# Example: Filtering by document_id="my-paper.pdf"
models.Filter(
    must=[
        models.FieldCondition(
            key="metadata.document_id",
            match=models.MatchValue(value="my-paper.pdf")
        )
    ],
    must_not=[]
)

# Example: Filtering by physical_page_index=5
models.Filter(
    must=[
        models.FieldCondition(
            key="metadata.physical_page_index",
            match=models.MatchValue(value=5)
        )
    ],
    must_not=[]
)

# Example: Combined filters (document_id + physical_page_index)
models.Filter(
    must=[
        models.FieldCondition(
            key="metadata.document_id",
            match=models.MatchValue(value="my-paper.pdf")
        ),
        models.FieldCondition(
            key="metadata.physical_page_index",
            match=models.MatchValue(value=5)
        )
    ],
    must_not=[]
)
```

**Lifecycle**:

1. User provides filter values via MCP tool call
2. `wrap_filters()` wrapper extracts values from kwargs
3. `make_filter()` translates to Qdrant conditions
4. Passed to `qdrant_connector.search()` as `query_filter` parameter
5. Applied in Qdrant query alongside vector search

## Data Flow

### 1. Configuration Loading (Server Startup)

```
Environment Variables / Defaults
    ↓
QdrantSettings.filterable_fields (List[FilterableField])
    ↓
filterable_fields_dict_with_conditions() → Dict[str, FilterableField]
    ↓
Passed to wrap_filters()
```

### 2. Signature Transformation (Server Initialization)

```
Original find() function signature:
    find(ctx, query, collection_name, query_filter=None)
    ↓
wrap_filters() processes FilterableField dict
    ↓
Generates Parameter objects for each field
    ↓
Updates __signature__ and __annotations__
    ↓
Wrapped function signature:
    find(ctx, query, collection_name, document_id=None, physical_page_index=None, page_label=None)
    ↓
Registered with FastMCP via @self.tool()
```

### 3. Tool Invocation (Runtime)

```
MCP Client sends tool call:
    {
        "name": "qdrant-find",
        "arguments": {
            "query": "machine learning",
            "collection_name": "papers",
            "document_id": "ml-survey.pdf"
        }
    }
    ↓
FastMCP deserializes to Python kwargs
    ↓
wrap_filters() wrapper function:
    - Extracts document_id="ml-survey.pdf"
    - Calls make_filter({"document_id": "ml-survey.pdf"})
    - Gets Filter(must=[FieldCondition(...)])
    ↓
Calls original find(query=..., collection_name=..., query_filter=Filter(...))
    ↓
qdrant_connector.search() with filter applied
    ↓
Returns filtered results
```

## Field Mapping

### metadata.document_id

- **MCP Parameter**: `document_id: str | None = None`
- **Qdrant Field**: `metadata.document_id`
- **Match Type**: `MatchValue` (exact string match)
- **Example Values**: `"research-paper.pdf"`, `"chapter-3.pdf"`

### metadata.physical_page_index

- **MCP Parameter**: `physical_page_index: int | None = None`
- **Qdrant Field**: `metadata.physical_page_index`
- **Match Type**: `MatchValue` (exact integer match)
- **Example Values**: `0`, `5`, `42` (0-based indexing)
- **Note**: Physical position in PDF, regardless of page labels

### metadata.page_label

- **MCP Parameter**: `page_label: str | None = None`
- **Qdrant Field**: `metadata.page_label`
- **Match Type**: `MatchValue` (exact string match)
- **Example Values**: `"i"`, `"iv"`, `"45"`, `"Appendix A"`
- **Note**: Original page number from PDF document

## Implementation Notes

### Type Safety

All filter parameters use Python's type hints:

- `Optional[str]` for keyword fields (document_id, page_label)
- `Optional[int]` for integer fields (physical_page_index)
- `Annotated[Type, Field(...)]` for FastMCP schema generation

### Default Values

All filter parameters default to `None`:

- Satisfies FR-008 (optional parameters)
- Allows backward compatibility (queries without filters)
- Filters only applied when values provided

### Validation

- **Type validation**: Handled by Pydantic/FastMCP parameter coercion
- **Existence validation**: Qdrant returns empty results for non-existent values
- **No runtime errors**: Invalid filter values cannot crash the server

### Performance

- **Filter overhead**: Negligible (metadata index lookup)
- **No vector recomputation**: Filters applied to result set
- **Index utilization**: Payload indexes created for all three fields in feature 001

## Testing Data

### Test Case 1: Single Filter (document_id)

**Input**:

```python
{
    "query": "neural networks",
    "collection_name": "papers",
    "document_id": "ml-fundamentals.pdf"
}
```

**Expected Filter**:

```python
Filter(must=[
    FieldCondition(key="metadata.document_id", match=MatchValue(value="ml-fundamentals.pdf"))
])
```

### Test Case 2: Single Filter (physical_page_index)

**Input**:

```python
{
    "query": "introduction",
    "collection_name": "papers",
    "physical_page_index": 0
}
```

**Expected Filter**:

```python
Filter(must=[
    FieldCondition(key="metadata.physical_page_index", match=MatchValue(value=0))
])
```

### Test Case 3: Combined Filters

**Input**:

```python
{
    "query": "conclusion",
    "collection_name": "papers",
    "document_id": "thesis.pdf",
    "page_label": "95"
}
```

**Expected Filter**:

```python
Filter(must=[
    FieldCondition(key="metadata.document_id", match=MatchValue(value="thesis.pdf")),
    FieldCondition(key="metadata.page_label", match=MatchValue(value="95"))
])
```

### Test Case 4: No Filters (Backward Compatibility)

**Input**:

```python
{
    "query": "quantum computing",
    "collection_name": "papers"
}
```

**Expected Filter**: `None` (all results returned)

## Future Considerations

### Additional Filter Operators

If range queries are needed for page numbers:

```python
# Example: Pages 10-20
FilterableField(
    name="physical_page_index_min",
    condition=">=",
    ...
)
FilterableField(
    name="physical_page_index_max",
    condition="<=",
    ...
)
```

### Compound Filters

For document sets or categories:

```python
FilterableField(
    name="document_category",
    field_type="keyword",
    condition="any",  # Match any of multiple values
    ...
)
```

### Full-Text Metadata Search

For searching within document titles or authors:

```python
# Requires Qdrant text match support
FilterableField(
    name="document_title",
    condition="contains",  # Not currently supported
    ...
)
```
